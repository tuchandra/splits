---
phase: 02-core-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main.ts
  - src/index.html
  - src/lib/storage.ts
autonomous: true

must_haves:
  truths:
    - "Diner names load from localStorage on page load"
    - "User can add a new diner"
    - "User can edit a diner's name"
    - "User can delete a diner"
    - "Empty/unnamed diners are omitted from display"
    - "Changes persist to localStorage"
  artifacts:
    - path: "src/lib/storage.ts"
      provides: "localStorage read/write for diner presets"
      exports: ["loadDiners", "saveDiners"]
    - path: "src/main.ts"
      provides: "App state management and diner UI rendering"
      min_lines: 100
  key_links:
    - from: "src/main.ts"
      to: "src/lib/storage.ts"
      via: "import and call on load/change"
      pattern: "import.*storage"
    - from: "src/main.ts"
      to: "localStorage"
      via: "storage module"
      pattern: "(loadDiners|saveDiners)"
---

<objective>
Build app state management foundation and diner entry UI.

Purpose: Establish the reactive state pattern and first user-facing feature (managing who's splitting the bill). This is the foundation all other UI builds on.

Output: Working diner management with localStorage persistence, compact editable name fields, add/delete controls.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-ui/02-CONTEXT.md
@src/lib/calculate.ts
@src/main.ts
@src/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage module and app state foundation</name>
  <files>src/lib/storage.ts, src/main.ts, src/index.html</files>
  <action>
Create `src/lib/storage.ts` with:
- `loadDiners(): string[]` - reads from localStorage key "splits-diners", returns empty array if not found, parses JSON
- `saveDiners(diners: string[]): void` - writes to localStorage key "splits-diners" as JSON

In `src/main.ts`, establish the app state pattern:
- Define `AppState` interface with: `diners: string[]` (diner names), `dishes: Dish[]` (empty for now), `taxCents: number`, `tipCents: number`, `enteredTotalCents: number | null`
- Define `Dish` interface with: `id: string`, `name: string`, `quantity: number`, `unitPriceCents: number`, `assignedTo: string[]`
- Create `let state: AppState` initialized with diners from `loadDiners()`, empty dishes, zeros for tax/tip, null for enteredTotal
- Create `render()` function that re-renders the entire app (simple approach, no virtual DOM needed for this scale)
- Call `render()` on initial load

Update `src/index.html`:
- Add minimal CSS in a `<style>` tag for basic layout (flex containers, input styling, button styling)
- Keep the `#app` div as the render target

Use vanilla TypeScript DOM manipulation (createElement, appendChild, event listeners). No framework needed for this scale.
  </action>
  <verify>
`bun build ./src/index.html --outdir=dist` succeeds without errors.
Open dist/index.html in browser - page loads without console errors.
  </verify>
  <done>
Storage module exports loadDiners/saveDiners. AppState interface defined. render() function exists and is called on load.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build diner entry UI with add/edit/delete</name>
  <files>src/main.ts</files>
  <action>
In the render() function, create the Diners section:

1. **Section header**: "Diners" as h2 or styled div

2. **Diner list** (compact, not full-width):
   - For each diner in state.diners, render:
     - Text input (editable name field, ~150px wide)
     - Delete button (X or trash icon/text)
   - Input `onchange`: update state.diners[index], call saveDiners(state.diners), re-render
   - Delete button `onclick`: remove from state.diners, call saveDiners(state.diners), re-render

3. **Add button**: "+ Add Diner" button
   - On click: push empty string to state.diners, call saveDiners(state.diners), re-render
   - Focus the new input after render (use setTimeout to ensure DOM is updated)

4. **Filter empty diners for display elsewhere** (preparation for Plan 02/03):
   - Create helper `getNamedDiners(): string[]` that returns state.diners.filter(d => d.trim() !== '')
   - Export this for use by other code

Key behaviors per CONTEXT.md:
- Compact layout (inputs not full-width, maybe inline-block or flex with gap)
- Empty/unnamed diners omitted from assignment chips (handled by getNamedDiners filter)
- Changes persist immediately via saveDiners()

Styling notes (Claude discretion on exact values):
- Use a container with display: flex, flex-wrap: wrap, gap for diner inputs
- Style inputs with border, padding, reasonable font size
- Style delete button to be subtle but visible (maybe red on hover)
- Style add button distinctly
  </action>
  <verify>
`bun build ./src/index.html --outdir=dist` succeeds.
Manual test in browser:
1. Page shows "Diners" section with "+ Add Diner" button
2. Click add - new empty input appears
3. Type a name - it saves (refresh page, name persists)
4. Click delete - diner removed (refresh page, stays removed)
5. Edit existing name - it updates (refresh page, update persists)
  </verify>
  <done>
Diner entry UI renders with editable name fields, delete buttons, and add button. Changes persist to localStorage across page refreshes.
  </done>
</task>

</tasks>

<verification>
1. `bun build ./src/index.html --outdir=dist` completes without errors
2. Browser test: localStorage persistence works (add diners, refresh, they're still there)
3. Browser test: delete removes diners, add creates new empty input
4. Browser test: editing a name persists the change
5. `bunx tsc --noEmit` passes (type checking)
</verification>

<success_criteria>
- Storage module exists with loadDiners/saveDiners functions
- AppState interface defined with diners, dishes, tax, tip, enteredTotal fields
- Diner UI renders with add/edit/delete functionality
- Changes persist to localStorage
- getNamedDiners helper filters out empty names
- Code compiles and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-ui/02-01-SUMMARY.md`
</output>
