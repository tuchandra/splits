---
phase: 03-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main.ts
  - src/index.html
autonomous: true

must_haves:
  truths:
    - "User can enter all data without using the mouse"
    - "Tab flows logically: diners -> dishes -> bill totals"
    - "Enter key adds new diner when in diner input"
    - "Enter key adds new dish when in last dish row"
    - "Focus is preserved after re-render"
  artifacts:
    - path: "src/main.ts"
      provides: "Enter key handlers for diners and dishes"
      contains: 'e.key === "Enter"'
    - path: "src/main.ts"
      provides: "Focus preservation in render function"
      contains: "activeElement"
  key_links:
    - from: "diner input keydown"
      to: "addDiner logic"
      via: "Enter key handler"
      pattern: 'dinerInput.*keydown.*Enter'
    - from: "render function"
      to: "focus restoration"
      via: "track and restore activeElement"
      pattern: "activeElement.*render.*focus"
---

<objective>
Implement keyboard-only data entry flow so users can enter all bill data (diners, dishes, totals) using only Tab and Enter keys, without touching the mouse.

Purpose: Desktop users can efficiently enter data using keyboard (UX-02). This is about natural Tab/Enter flow, not modifier shortcuts.

Output: Complete Tab flow through all inputs, Enter key creates new rows, focus preserved during re-renders.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-polish/03-RESEARCH.md

@src/main.ts
@src/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Enter key support for diner inputs</name>
  <files>src/main.ts</files>
  <action>
Add Enter key handler to diner name inputs to add a new diner and focus it:

1. In renderDinersSection, add keydown listener to each diner input:
   ```typescript
   input.addEventListener("keydown", (e) => {
     if (e.key === "Enter") {
       e.preventDefault();
       // Add new diner
       state.diners.push("");
       saveDiners(state.diners);
       render();
       // Focus new input after render
       setTimeout(() => {
         const inputs = document.querySelectorAll<HTMLInputElement>(".diner-input");
         const lastInput = inputs[inputs.length - 1];
         lastInput?.focus();
       }, 0);
     }
   });
   ```

2. This mirrors the existing "Add Diner" button behavior but triggered by Enter key.
  </action>
  <verify>
1. Open app, click in first diner input
2. Type a name, press Enter
3. New empty diner input appears and is focused
4. Repeat - each Enter adds and focuses new diner
5. Tab to leave diner section
  </verify>
  <done>
Enter key in any diner input adds a new diner and focuses the new input.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Enter key support for dish inputs</name>
  <files>src/main.ts</files>
  <action>
Add Enter key handlers to dish inputs for smooth keyboard entry:

1. In renderDishesSection, add Enter key to dish name input:
   - Enter moves focus to qty input of same row (advance within row)
   ```typescript
   nameInput.addEventListener("keydown", (e) => {
     if (e.key === "Enter") {
       e.preventDefault();
       // Find the qty input in the same dish card and focus it
       const row = (e.target as HTMLElement).closest(".dish-card");
       const qtyInput = row?.querySelector<HTMLInputElement>(".dish-qty-input");
       qtyInput?.focus();
     }
   });
   ```

2. Add Enter key to qty input:
   - Enter moves focus to price input of same row
   ```typescript
   qtyInput.addEventListener("keydown", (e) => {
     if (e.key === "Enter") {
       e.preventDefault();
       const row = (e.target as HTMLElement).closest(".dish-card");
       const priceInput = row?.querySelector<HTMLInputElement>(".dish-price-input");
       priceInput?.focus();
     }
   });
   ```

3. Add Enter key to price input (last dish row only):
   - If last row AND dish has a name, add new dish and focus its name input
   - This mirrors the existing Tab behavior but also works for Enter
   ```typescript
   priceInput.addEventListener("keydown", (e) => {
     if (e.key === "Enter") {
       e.preventDefault();
       const idx = Number((e.target as HTMLInputElement).dataset.index);
       const isLastRow = idx === state.dishes.length - 1;
       const currentDish = state.dishes[idx];

       if (isLastRow && currentDish && currentDish.name.trim() !== "") {
         // Add new dish (same as Tab behavior)
         state.dishes.push({
           id: crypto.randomUUID(),
           name: "",
           quantity: 1,
           unitPriceCents: 0,
           assignedTo: [],
         });
         render();
         setTimeout(() => {
           const nameInputs = document.querySelectorAll<HTMLInputElement>(".dish-name-input");
           const lastNameInput = nameInputs[nameInputs.length - 1];
           lastNameInput?.focus();
         }, 0);
       } else if (!isLastRow) {
         // Not last row - move to next dish's name input
         const nextNameInput = document.querySelectorAll<HTMLInputElement>(".dish-name-input")[idx + 1];
         nextNameInput?.focus();
       }
       // If last row but empty name, do nothing (user should fill in name first)
     }
   });
   ```
  </action>
  <verify>
1. Add a dish, type name, press Enter -> qty focused
2. Type qty, press Enter -> price focused
3. Type price, press Enter -> new dish added, name focused
4. Fill in second dish, Enter through all fields -> third dish added
5. Verify Tab still works as before (Tab from price adds new row if last row has name)
  </verify>
  <done>
Enter key advances through dish fields (name -> qty -> price) and creates new dish from last row's price field.
  </done>
</task>

<task type="auto">
  <name>Task 3: Focus preservation during re-render</name>
  <files>src/main.ts</files>
  <action>
Modify the render function to preserve focus position across re-renders, preventing focus loss during typing:

1. At the start of render(), capture the active element's identifying data:
   ```typescript
   function render(): void {
     // Track focused element before clearing DOM
     const activeEl = document.activeElement as HTMLElement | null;
     const focusData: { type: string; index: string | undefined } | null = null;

     if (activeEl) {
       // Identify by class and data-index
       if (activeEl.classList.contains("diner-input")) {
         focusData = { type: "diner", index: activeEl.dataset.index };
       } else if (activeEl.classList.contains("dish-name-input")) {
         focusData = { type: "dish-name", index: activeEl.dataset.index };
       } else if (activeEl.classList.contains("dish-qty-input")) {
         focusData = { type: "dish-qty", index: activeEl.dataset.index };
       } else if (activeEl.classList.contains("dish-price-input")) {
         focusData = { type: "dish-price", index: activeEl.dataset.index };
       } else if (activeEl.classList.contains("totals-input")) {
         // For totals inputs, identify by label (tax, tip, total)
         const label = activeEl.closest(".input-group")?.querySelector("label")?.textContent?.toLowerCase();
         focusData = { type: "totals-" + (label || "unknown"), index: undefined };
       }
     }

     // ... existing render code ...

     // Restore focus after render
     if (focusData) {
       let selector: string | null = null;
       if (focusData.type === "diner") {
         selector = `.diner-input[data-index="${focusData.index}"]`;
       } else if (focusData.type === "dish-name") {
         selector = `.dish-name-input[data-index="${focusData.index}"]`;
       } else if (focusData.type === "dish-qty") {
         selector = `.dish-qty-input[data-index="${focusData.index}"]`;
       } else if (focusData.type === "dish-price") {
         selector = `.dish-price-input[data-index="${focusData.index}"]`;
       } else if (focusData.type.startsWith("totals-")) {
         const labelText = focusData.type.replace("totals-", "");
         // Find input group with matching label
         const groups = document.querySelectorAll(".input-group");
         for (const group of groups) {
           const label = group.querySelector("label")?.textContent?.toLowerCase();
           if (label === labelText) {
             const input = group.querySelector<HTMLInputElement>(".totals-input");
             input?.focus();
             return; // Early return, focus set
           }
         }
       }

       if (selector) {
         const element = document.querySelector<HTMLElement>(selector);
         element?.focus();
       }
     }
   }
   ```

2. Move focus restoration to end of render() using setTimeout(0) to ensure DOM is fully updated:
   ```typescript
   // After all appendChild calls...
   setTimeout(() => {
     if (focusData) {
       // ... restore focus logic here ...
     }
   }, 0);
   ```

Note: The existing code already uses setTimeout for focus after add operations. This enhancement tracks and restores focus during normal re-renders triggered by value changes.
  </action>
  <verify>
1. Click in a diner input, type some text
2. Observe that after onChange fires and re-render happens, cursor is still in the same input
3. Do the same for dish name, qty, price inputs
4. Do the same for tax/tip/total inputs
5. Focus should remain in the active input after each re-render
  </verify>
  <done>
Focus is tracked before re-render and restored after, preventing cursor jump during typing.
  </done>
</task>

</tasks>

<verification>
Full keyboard-only entry test:
1. Open app in browser
2. Tab to first diner input (may need Tab from URL bar)
3. Type "Alice", press Enter -> new diner focused
4. Type "Bob", press Tab -> should move to dishes section
5. Click "+ Add Dish" (only button interaction allowed)
6. Type "Burger", Enter -> qty focused
7. Type "1", Enter -> price focused
8. Type "15", Enter -> new dish added, name focused
9. Type "Fries", Enter, "1", Enter, "5", Tab -> moves to bill totals
10. Tab through Tax, Tip, Total inputs
11. At no point should typing cause focus to jump unexpectedly
</verification>

<success_criteria>
- Enter key adds new diner from any diner input
- Enter key advances through dish fields (name -> qty -> price)
- Enter key on last dish price (with name) creates new dish
- Tab flow is logical: diners -> dishes -> totals
- Focus preserved during re-renders (no cursor jump while typing)
- All existing functionality still works (Tab from price creates dish)
</success_criteria>

<output>
After completion, create `.planning/phases/03-polish/03-02-SUMMARY.md`
</output>
