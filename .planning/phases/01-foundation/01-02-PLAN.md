---
phase: 01-foundation
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/calculate.ts
  - tests/calculate.test.ts
autonomous: true

must_haves:
  truths:
    - "Shared items split evenly among assigned people"
    - "Tax/tip/fees distributed proportionally by subtotal"
    - "Final amount per person sums correctly to bill total"
    - "Remainder pennies distributed without loss"
    - "Unassigned items tracked separately"
  artifacts:
    - path: "src/lib/calculate.ts"
      provides: "Pure calculation functions for bill splitting"
      exports: ["calculateBill", "splitEvenly", "allocateProportionally"]
      min_lines: 80
    - path: "tests/calculate.test.ts"
      provides: "Comprehensive tests for calculation logic"
      contains: "describe"
      min_lines: 100
  key_links:
    - from: "tests/calculate.test.ts"
      to: "src/lib/calculate.ts"
      via: "import"
      pattern: "import.*from.*calculate"
    - from: "src/lib/calculate.ts"
      to: "allocateProportionally"
      via: "internal call"
      pattern: "allocateProportionally\\("
---

<objective>
Implement bill splitting calculation logic using TDD (test-driven development).

Purpose: Create reliable, well-tested pure functions that correctly split bills with proportional tax/tip/fee allocation and handle edge cases like remainder pennies and unassigned items.

Output: Fully tested `calculateBill` function and supporting utilities that satisfy CALC-01, CALC-02, CALC-03 requirements.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<feature>
  <name>Bill Calculation Engine</name>
  <files>src/lib/calculate.ts, tests/calculate.test.ts</files>
  <behavior>
    Core types (all money as integer cents):

    ```typescript
    interface LineItem {
      id: string;
      name: string;
      amountCents: number;
      assignedTo: string[];  // person IDs, empty = unassigned
    }

    interface BillInput {
      items: LineItem[];
      taxCents: number;
      tipCents: number;
      feesCents: number;
      participants: string[];  // all people involved
    }

    interface PersonShare {
      personId: string;
      items: { itemId: string; itemName: string; shareCents: number }[];
      subtotalCents: number;   // sum of item shares
      taxCents: number;        // proportional tax
      tipCents: number;        // proportional tip
      feesCents: number;       // proportional fees
      totalCents: number;      // subtotal + tax + tip + fees
    }

    interface BillResult {
      shares: PersonShare[];
      unassignedItems: LineItem[];
      totalCents: number;      // sum of all shares (should match bill total)
    }
    ```

    Test cases (input -> expected output):

    1. Simple even split:
       - Input: 1 item ($10.00), 2 people assigned
       - Output: Each person gets $5.00 subtotal

    2. Split with remainder:
       - Input: 1 item ($10.01), 2 people assigned
       - Output: One person gets $5.01, other gets $5.00 (total = $10.01)

    3. Proportional tax allocation:
       - Input: Alice has $30 subtotal, Bob has $20 subtotal, $5 tax
       - Output: Alice gets $3 tax, Bob gets $2 tax (60%/40% split)

    4. Proportional tip allocation:
       - Input: Alice has $30 subtotal, Bob has $20 subtotal, $10 tip
       - Output: Alice gets $6 tip, Bob gets $4 tip (60%/40% split)

    5. Proportional fees allocation:
       - Same as tax/tip

    6. Multiple items, mixed assignment:
       - Input: Burger ($15) -> Alice, Fries ($5) -> Alice+Bob, Drink ($4) -> Bob
       - Output: Alice subtotal = $15 + $2.50 = $17.50, Bob subtotal = $2.50 + $4 = $6.50

    7. Unassigned items tracked:
       - Input: 2 items, only 1 assigned
       - Output: unassignedItems contains the unassigned item

    8. Full bill calculation:
       - Input: Items totaling $50, tax $5, tip $10, fees $2
       - Output: All shares sum to $67, proportions correct

    9. Edge case - zero subtotal:
       - Input: Items assigned but all $0
       - Output: Tax/tip/fees allocated evenly (fallback)

    10. Edge case - single person:
        - Input: All items to one person
        - Output: That person pays 100% of everything
  </behavior>
  <implementation>
    Implement these functions in src/lib/calculate.ts:

    1. `splitEvenly(amountCents: number, personIds: string[]): Map<string, number>`
       - Divide amount evenly, distribute remainder pennies round-robin
       - Handle empty personIds (return empty Map)

    2. `allocateProportionally(totalCents: number, shares: { id: string; weight: number }[]): Map<string, number>`
       - Allocate based on weight ratios
       - Use Math.floor for initial allocation
       - Distribute remainder pennies to largest remainder first (or round-robin)
       - Handle zero total weight (return empty Map or even split)

    3. `calculateBill(input: BillInput): BillResult`
       - Step 1: For each item, split among assignedTo using splitEvenly
       - Step 2: Accumulate each person's subtotal from their item shares
       - Step 3: Allocate tax proportionally by subtotal
       - Step 4: Allocate tip proportionally by subtotal
       - Step 5: Allocate fees proportionally by subtotal
       - Step 6: Sum each person's total
       - Step 7: Collect unassigned items
       - Step 8: Return BillResult

    Key constraints:
    - All money as integer cents (never floating point)
    - Pure functions (no side effects, no mutation of inputs)
    - Sum of all outputs must equal sum of all inputs (no lost pennies)
    - Handle edge cases gracefully (empty arrays, zero amounts)
  </implementation>
</feature>

<tdd_cycle>

## RED Phase: Write Failing Tests

Create tests/calculate.test.ts with comprehensive test cases BEFORE implementing.

```typescript
import { describe, test, expect } from "bun:test";
import { calculateBill, splitEvenly, allocateProportionally } from "../src/lib/calculate";

describe("splitEvenly", () => {
  test("splits evenly when divisible", () => {
    const result = splitEvenly(1000, ["alice", "bob"]);
    expect(result.get("alice")).toBe(500);
    expect(result.get("bob")).toBe(500);
  });

  test("distributes remainder penny", () => {
    const result = splitEvenly(1001, ["alice", "bob"]);
    const total = (result.get("alice") ?? 0) + (result.get("bob") ?? 0);
    expect(total).toBe(1001);
  });

  test("handles single person", () => {
    const result = splitEvenly(1000, ["alice"]);
    expect(result.get("alice")).toBe(1000);
  });

  test("handles empty array", () => {
    const result = splitEvenly(1000, []);
    expect(result.size).toBe(0);
  });
});

describe("allocateProportionally", () => {
  test("allocates by weight ratio", () => {
    const result = allocateProportionally(500, [
      { id: "alice", weight: 30 },
      { id: "bob", weight: 20 },
    ]);
    expect(result.get("alice")).toBe(300); // 60%
    expect(result.get("bob")).toBe(200);   // 40%
  });

  test("handles remainder distribution", () => {
    const result = allocateProportionally(100, [
      { id: "alice", weight: 1 },
      { id: "bob", weight: 1 },
      { id: "charlie", weight: 1 },
    ]);
    const total = [...result.values()].reduce((a, b) => a + b, 0);
    expect(total).toBe(100); // No lost pennies
  });

  test("handles zero total weight", () => {
    const result = allocateProportionally(500, [
      { id: "alice", weight: 0 },
      { id: "bob", weight: 0 },
    ]);
    expect(result.size).toBe(0);
  });
});

describe("calculateBill", () => {
  test("splits shared item evenly", () => {
    const result = calculateBill({
      items: [{ id: "1", name: "Pizza", amountCents: 2000, assignedTo: ["alice", "bob"] }],
      taxCents: 0,
      tipCents: 0,
      feesCents: 0,
      participants: ["alice", "bob"],
    });

    const alice = result.shares.find(s => s.personId === "alice");
    const bob = result.shares.find(s => s.personId === "bob");
    expect(alice?.subtotalCents).toBe(1000);
    expect(bob?.subtotalCents).toBe(1000);
  });

  test("allocates tax proportionally", () => {
    const result = calculateBill({
      items: [
        { id: "1", name: "Steak", amountCents: 3000, assignedTo: ["alice"] },
        { id: "2", name: "Salad", amountCents: 2000, assignedTo: ["bob"] },
      ],
      taxCents: 500,
      tipCents: 0,
      feesCents: 0,
      participants: ["alice", "bob"],
    });

    const alice = result.shares.find(s => s.personId === "alice");
    const bob = result.shares.find(s => s.personId === "bob");
    expect(alice?.taxCents).toBe(300); // 60% of $5
    expect(bob?.taxCents).toBe(200);   // 40% of $5
  });

  test("tracks unassigned items", () => {
    const result = calculateBill({
      items: [
        { id: "1", name: "Burger", amountCents: 1500, assignedTo: ["alice"] },
        { id: "2", name: "Mystery Item", amountCents: 500, assignedTo: [] },
      ],
      taxCents: 0,
      tipCents: 0,
      feesCents: 0,
      participants: ["alice"],
    });

    expect(result.unassignedItems).toHaveLength(1);
    expect(result.unassignedItems[0].id).toBe("2");
  });

  test("total equals sum of shares", () => {
    const result = calculateBill({
      items: [
        { id: "1", name: "Item 1", amountCents: 1500, assignedTo: ["alice"] },
        { id: "2", name: "Item 2", amountCents: 2500, assignedTo: ["bob"] },
        { id: "3", name: "Shared", amountCents: 1000, assignedTo: ["alice", "bob"] },
      ],
      taxCents: 500,
      tipCents: 1000,
      feesCents: 200,
      participants: ["alice", "bob"],
    });

    const sumOfTotals = result.shares.reduce((sum, s) => sum + s.totalCents, 0);
    expect(sumOfTotals).toBe(result.totalCents);
    expect(result.totalCents).toBe(1500 + 2500 + 1000 + 500 + 1000 + 200);
  });
});
```

Run `bun test` - tests should FAIL (functions not implemented yet).
Commit: `test(01-02): add failing tests for bill calculation`

## GREEN Phase: Implement to Pass

Implement functions in src/lib/calculate.ts to make all tests pass.

Key implementation details:
- Use Math.floor for division, track remainders
- Distribute remainders round-robin or by largest fractional part
- Build PersonShare objects incrementally
- Filter unassigned items at the end

Run `bun test` - all tests should PASS.
Commit: `feat(01-02): implement bill calculation functions`

## REFACTOR Phase (if needed)

Review implementation for:
- Code clarity (rename unclear variables)
- DRY violations (extract repeated logic)
- Type safety (no `any`, proper null handling)

Run `bun test` after any changes.
Commit only if changes made: `refactor(01-02): clean up calculation functions`

</tdd_cycle>

<verification>
Run these commands to verify the plan is complete:

```bash
# All tests pass
bun test

# No TypeScript errors
bunx tsc --noEmit

# Functions are exported
grep -E "^export function" src/lib/calculate.ts

# Build still works with new code
bun run build
```
</verification>

<success_criteria>
1. `bun test` passes all calculation tests (10+ test cases)
2. `splitEvenly` correctly divides amounts and handles remainders
3. `allocateProportionally` distributes by weight ratios without losing pennies
4. `calculateBill` produces correct PersonShare[] for all test scenarios
5. Unassigned items are tracked in BillResult
6. Sum of all person totals equals bill total (no lost pennies)
7. All money values are integer cents (no floating point)
8. Functions are pure (no side effects)
9. Requirements CALC-01, CALC-02, CALC-03 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
